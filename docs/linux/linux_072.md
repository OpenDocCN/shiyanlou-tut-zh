# 第 2 节 mykernel 实验指导（操作系统是如何工作的）

使用实验楼的虚拟机打开 shell

```
cd LinuxKernel/linux-3.9.4
qemu -kernel arch/x86/boot/bzImage 
```

然后 cd mykernel 您可以看到 qemu 窗口输出的内容的代码 mymain.c 和 myinterrupt.c

使用自己的 Linux 系统环境搭建过程参见[mykernel](https://github.com/mengning/mykernel),其中也可以找到一个简单的时间片轮转多道程序内核代码

实验要求：

*   完成一个简单的时间片轮转多道程序内核代码，代码见视频中或从[mykernel](https://github.com/mengning/mykernel)找。
*   详细分析该精简内核的源代码并给出实验截图，撰写一篇署名博客，并在博客文章中注明“真实姓名（与最后申请证书的姓名务必一致） + 原创作品转载请注明出处 + 《Linux 内核分析》MOOC 课程 http://mooc.study.163.com/course/USTC-1000029000 ”，博客内容的具体要求如下：
    *   题目自拟，内容围绕操作系统是如何工作的进行；
    *   博客中需要使用实验截图
    *   博客内容中需要仔细分析进程的启动和进程的切换机制
    *   总结部分需要阐明自己对“操作系统是如何工作的”理解。

请提交博客文章 URL 到网易云课堂 MOOC 平台 Linux 内核分析 MOOC 课程，编辑成一个链接可以直接点击打开。(学堂在线上的学员注意提交博客 URL 到学堂在线上)

欢迎加入 QQ 群孟宁 MOOC 415464550 交流提问。

## 跟踪分析 Linux 内核的启动过程

使用实验楼的虚拟机打开 shell

```
cd LinuxKernel/
qemu -kernel linux-3.18.6/arch/x86/boot/bzImage -initrd rootfs.img 
```

内核启动完成后进入[menu](https://github.com/mengning/menu)程序（[《软件工程 C 编码实践篇》的课程项目](http://mooc.study.163.com/course/YOOKCS0008-1000002006)），支持三个命令 help、version 和 quit，您也可以添加更多的命令，对选修过《软件工程 C 编码实践篇》的童鞋应该是 a piece of cake.

使用 gdb 跟踪调试内核

```
qemu -kernel linux-3.18.6/arch/x86/boot/bzImage -initrd rootfs.img -s -S # 关于-s 和-S 选项的说明：
 -S freeze CPU at startup (use ’c’ to start execution)
 -s shorthand for -gdb tcp::1234 若不想使用 1234 端口，则可以使用-gdb tcp:xxxx 来取代-s 选项 
```

另开一个 shell 窗口

```
gdb
（gdb）file linux-3.18.6/vmlinux # 在 gdb 界面中 targe remote 之前加载符号表
（gdb）target remote:1234 # 建立 gdb 和 gdbserver 之间的连接,按 c 让 qemu 上的 Linux 继续运行
（gdb）break start_kernel # 断点的设置可以在 target remote 之前，也可以在之后 
```

实验要求：

*   使用 gdb 跟踪调试内核从 start_kernel 到 init 进程启动
*   详细分析从 start*kernel 到 init 进程启动的过程并结合实验截图撰写一篇署名博客，并在博客文章中注明“真实姓名（与最后申请证书的姓名务必一致） + 原创作品转载请注明出处 + 《Linux 内核分析》MOOC 课程 http://mooc.study.163.com/course/USTC-1000029000 ”，博客内容的具体要求如下：

    *   题目自拟，内容围绕 Linux 内核的启动过程，即从 start* kernel 到 init 进程启动；
*   博客中需要使用实验截图
*   博客内容中需要仔细分析 start_kernel 函数的执行过程
*   总结部分需要阐明自己对“Linux 系统启动过程”的理解，尤其是 idle 进程、1 号进程是怎么来的。

请提交博客文章 URL 到网易云课堂 MOOC 平台 Linux 内核分析 MOOC 课程，编辑成一个链接可以直接点击打开(学堂在线上的学员注意提交博客 URL 到学堂在线上)

## 使用库函数 API 和 C 代码中嵌入汇编代码两种方式使用同一个系统调用

*   选择一个系统调用（13 号系统调用 time 除外），系统调用列表参见 http://codelab.shiyanlou.com/xref/linux-3.18.6/arch/x86/syscalls/syscall_32.tbl
*   参考视频中的方式使用库函数 API 和 C 代码中嵌入汇编代码两种方式使用同一个系统调用
*   根据本周所学知识分析系统调用的工作过程，撰写一篇署名博客，并在博客文章中注明“真实姓名（与最后申请证书的姓名务必一致） + 原创作品转载请注明出处 + 《Linux 内核分析》MOOC 课程 http://mooc.study.163.com/course/USTC-1000029000 ”，博客内容的具体要求如下：
    *   题目自拟，内容围绕系统调用的工作机制进行
    *   博客中需要使用实验截图
    *   博客内容中需要仔细分析汇编代码调用系统调用的工作过程，特别是参数的传递的方式等。
    *   总结部分需要阐明自己对“系统调用的工作机制”的理解。

请提交博客文章 URL 到网易云课堂 MOOC 平台，编辑成一个链接可以直接点击打开。(学堂在线上的学员注意提交博客 URL 到学堂在线上)

## 分析 system_call 中断处理过程

*   使用 gdb 跟踪分析一个系统调用内核函数（您上周选择的那一个系统调用），系统调用列表参见 http://codelab.shiyanlou.com/xref/linux-3.18.6/arch/x86/syscalls/syscall_32.tbl ,推荐在实验楼 Linux 虚拟机环境下完成实验。
*   根据本周所学知识分析系统调用的过程，从 system_call 开始到 iret 结束之间的整个过程，并画出简要准确的流程图，撰写一篇署名博客，并在博客文章中注明“真实姓名（与最后申请证书的姓名务必一致） + 原创作品转载请注明出处 + 《Linux 内核分析》MOOC 课程 http://mooc.study.163.com/course/USTC-1000029000 ”，博客内容的具体要求如下：
*   题目自拟，内容围绕系统调用 system_call 的处理过程进行；
*   博客内容中需要仔细分析 system_call 对应的汇编代码的工作过程，特别注意系统调用返回 iret 之前的进程调度时机等。
*   总结部分需要阐明自己对“系统调用处理过程”的理解，进一步推广到一般的中断处理过程。

请提交博客文章 URL 到网易云课堂 MOOC 平台，编辑成一个链接可以直接点击打开。(学堂在线上的学员注意提交博客 URL 到学堂在线上)

## 分析 Linux 内核创建一个新进程的过程

*   阅读理解 task_struct 数据结构 http://codelab.shiyanlou.com/xref/linux-3.18.6/include/linux/sched.h#1235；
*   分析 fork 函数对应的内核处理过程 sys*clone，理解创建一个新进程如何创建和修改 task*struct 数据结构；
*   使用 gdb 跟踪分析一个 fork 系统调用内核处理函数 sys_clone ，验证您对 Linux 系统创建一个新进程的理解,推荐在实验楼 Linux 虚拟机环境下完成实验。 特别关注新进程是从哪里开始执行的？为什么从那里能顺利执行下去？即执行起点与内核堆栈如何保证一致。
*   根据本周所学知识分析 fork 函数对应的系统调用处理过程，撰写一篇署名博客，并在博客文章中注明“真实姓名（与最后申请证书的姓名务必一致） + 原创作品转载请注明出处 + 《Linux 内核分析》MOOC 课程 http://mooc.study.163.com/course/USTC-1000029000 ”，博客内容的具体要求如下：
    *   题目自拟，内容围绕对 Linux 系统如何创建一个新进程进行；
    *   可以结合实验截图、绘制堆栈状态执行流程图等；
    *   博客内容中需要仔细分析新进程的执行起点及对应的堆栈状态等。
    *   总结部分需要阐明自己对“Linux 系统创建一个新进程”的理解

请提交博客文章 URL 到网易云课堂 MOOC 平台，编辑成一个链接可以直接点击打开。

## Linux 内核如何装载和启动一个可执行程

1.  理解编译链接的过程和 ELF 可执行文件格式，详细内容参考本周第一节；​
2.  编程使用 exec*库函数加载一个可执行文件，动态链接分为可执行程序装载时动态链接和运行时动态链接，编程练习动态链接库的这两种使用方式，详细内容参考本周第二节；
3.  使用 gdb 跟踪分析一个 execve 系统调用内核处理函数 sys_execve ，验证您对 Linux 系统加载可执行程序所需处理过程的理解，详细内容参考本周第三节；推荐在实验楼 Linux 虚拟机环境下完成实验。
4.  特别关注新的可执行程序是从哪里开始执行的？为什么 execve 系统调用返回后新的可执行程序能顺利执行？对于静态链接的可执行程序和动态链接的可执行程序 execve 系统调用返回时会有什么不同？
5.  根据本周所学知识分析 exec*函数对应的系统调用处理过程，撰写一篇署名博客，并在博客文章中注明“真实姓名（与最后申请证书的姓名务必一致） + 原创作品转载请注明出处 + 《Linux 内核分析》MOOC 课程 http://mooc.study.163.com/course/USTC-1000029000 ”，博客内容的具体要求如下：
    1.  题目自拟，内容围绕对 Linux 内核如何装载和启动一个可执行程序；
    2.  可以结合实验截图、ELF 可执行文件格式、用户态的相关代码等；
    3.  博客内容中需要仔细分析新可执行程序的执行起点及对应的堆栈状态等。
    4.  总结部分需要阐明自己对“Linux 内核装载和启动一个可执行程序”的理解

请提交博客文章 URL 到网易云课堂 MOOC 平台，编辑成一个链接可以直接点击打开。(学堂在线上的学员注意提交博客 URL 到学堂在线上)

## 理解进程调度时机跟踪分析进程调度与进程切换的过程

1.  理解 Linux 系统中进程调度的时机，可以在内核代码中搜索 schedule()函数，看都是哪里调用了 schedule()，判断我们课程内容中的总结是否准确；
2.  使用 gdb 跟踪分析一个 schedule()函数 ，验证您对 Linux 系统进程调度与进程切换过程的理解；推荐在实验楼 Linux 虚拟机环境下完成实验。
3.  特别关注并仔细分析 switch_to 中的汇编代码，理解进程上下文的切换机制，以及与中断上下文切换的关系；
4.  根据本周所学知识分析并理解 Linux 中进程调度与进程切换过程，撰写一篇署名博客，并在博客文章中注明“真实姓名（与最后申请证书的姓名务必一致） + 原创作品转载请注明出处 + 《Linux 内核分析》MOOC 课程 http://mooc.study.163.com/course/USTC-1000029000 ”，博客内容的具体要求如下：
    1.  题目自拟，内容围绕对进程调度的时机和进程切换进行；
    2.  可以结合关键代码、实验截图、堆栈状态、CPU 寄存器状态等；
    3.  博客内容中需要仔细分析进程的调度时机、switch_to 及对应的堆栈状态等。
    4.  总结部分需要阐明自己对“Linux 系统一般执行过程”的理解

请提交博客文章 URL 到网易云课堂 MOOC 平台，编辑成一个链接可以直接点击打开。(学堂在线上的学员注意提交博客 URL 到学堂在线上)

## Linux 内核学习总结

1.  用自己的话简要总结您对 Linux 系统的理解及学习 Linux 内核的心得；
2.  将您之前的所有博客作业做成目录列表，可以修改原博客理解有误或不准确的地方，可以在目录中给每篇博客加个简要引言，总之，您的这篇学习总结博客能为其他学习者提供一个参考索引；
3.  根据本课程所学知识阐述您对 Linux 系统的理解，撰写一篇署名博客，并在博客文章中注明“真实姓名（与最后申请证书的姓名务必一致） + 原创作品转载请注明出处 + 《Linux 内核分析》MOOC 课程 http://mooc.study.163.com/course/USTC-1000029000 ”，博客内容的具体要求如下：
    1.  题目自拟，内容围绕您对 Linux 系统的理解及学习 Linux 内核的心得进行；
    2.  将您之前的所有博客作业做成目录列表放在博客中；
    3.  总结部分：您在学习《Linux 内核分析》课程中最大的收获？学习完《Linux 内核分析》课程后您最大的遗憾是什么？

请提交博客文章 URL 到网易云课堂 MOOC 平台，编辑成一个链接可以直接点击打开。(学堂在线上的学员注意提交博客 URL 到学堂在线上)