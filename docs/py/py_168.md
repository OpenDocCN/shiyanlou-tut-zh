# 第 7 节 时区处理

## 一、实验介绍

　　时间序列处理工作中最让人不爽的就是对时区的处理。尤其是夏令时（DST）转变，这是一种最常见的麻烦事。就这一点来说，许多人选择以协调世界时（UTC，它是格林尼治标准时间（Greenwich Mean Time）的接替者，目前已经是国际标准了）来处理时间序列。时区是以 UTC 偏移量的形式表示的。

　　在 Python 中，时区信息来自第三方库 pytz，它使 Python 可以使用 Olson 数据库（汇编了世界时区信息）。这对历史数据非常重要，这是因为由于各地政府的各种突发奇想，夏令时转变日期（甚至 UTC 偏移量）已经发生过多次改变。 　　 　　有关 pytz 库的更多信息，请查阅其文档。由于 pandas 包装了 pytz 的功能，因此我们可以不用记忆其 API，只要记得时区的名称即可。

```py
In [22]: import pytz

In [23]: pytz.common_timezones[225]
Out[23]: 'Asia/Chongqing'

In [24]: tz = pytz.timezone('Asia/Chongqing')

In [25]: tz
Out[25]: <DstTzInfo 'Asia/Chongqing' LMT+7:06:00 STD> 
```

　　pandas 中的方法即可以接受时区名也可以接受这种对象。我建议只用时区名。

## 二、本地化和转换

　　默认情况下，pandas 中的时间序列是单纯的时区，看看下面这个时间序列：

```py
In [43]: rng = pd.date_range('3/9/2015 9:30', periods = 10, freq = 'D')

In [44]: ts = Series(np.random.randn(len(rng)), index = rng)

In [45]: # 其索引的 tz 字段为 None

In [46]: print(ts.index.tz)
None

In [47]: #在生成日期范围的时候还可以加上一个时区集

In [48]: pd.date_range('1/1/2015 9:30',periods=5,freq='D',tz='UTC')
Out[48]: 
DatetimeIndex(['2015-01-01 09:30:00+00:00', '2015-01-02 09:30:00+00:00',
               '2015-01-03 09:30:00+00:00', '2015-01-04 09:30:00+00:00',
               '2015-01-05 09:30:00+00:00'],
              dtype='datetime64[ns]', freq='D', tz='UTC') 
```

　　从单纯到本地化的转换是通过 tz_localize 方法处理的：

```py
In [58]: ts_utc = ts.tz_localize('UTC')

In [59]: ts_utc
Out[59]: 
2015-03-09 09:30:00+00:00    1.179454
2015-03-10 09:30:00+00:00   -0.709411
2015-03-11 09:30:00+00:00    0.826699
2015-03-12 09:30:00+00:00    0.923428
2015-03-13 09:30:00+00:00   -0.929258
2015-03-14 09:30:00+00:00   -0.242388
2015-03-15 09:30:00+00:00    0.299958
2015-03-16 09:30:00+00:00    0.079523
2015-03-17 09:30:00+00:00    1.727790
2015-03-18 09:30:00+00:00    0.673311
Freq: D, dtype: float64

In [60]: ts_utc.index
Out[60]: 
DatetimeIndex(['2015-03-09 09:30:00+00:00', '2015-03-10 09:30:00+00:00',
               '2015-03-11 09:30:00+00:00', '2015-03-12 09:30:00+00:00',
               '2015-03-13 09:30:00+00:00', '2015-03-14 09:30:00+00:00',
               '2015-03-15 09:30:00+00:00', '2015-03-16 09:30:00+00:00',
               '2015-03-17 09:30:00+00:00', '2015-03-18 09:30:00+00:00'],
              dtype='datetime64[ns]', freq='D', tz='UTC') 
```

　　一旦时间序列被本地化到某个特定时区，就可以用 tz——convert 将其转换到别的时区了：

```py
In [61]: ts_utc.tz_convert('Asia/Chongqing')
Out[61]: 
2015-03-09 17:30:00+08:00    1.179454
2015-03-10 17:30:00+08:00   -0.709411
2015-03-11 17:30:00+08:00    0.826699
2015-03-12 17:30:00+08:00    0.923428
2015-03-13 17:30:00+08:00   -0.929258
2015-03-14 17:30:00+08:00   -0.242388
2015-03-15 17:30:00+08:00    0.299958
2015-03-16 17:30:00+08:00    0.079523
2015-03-17 17:30:00+08:00    1.727790
2015-03-18 17:30:00+08:00    0.673311
Freq: D, dtype: float64 
```

## 三、操作时区意识型 Timestamp 对象

　　跟时间序列和日期范围差不多，Timestamp 对象也能被从单纯型本地化为时区意识型（time zone-aware），并从一个时区转换到另一个时区：

```py
In [67]: stamp = pd.Timestamp('2015-08-12 04:00')

In [68]: stamp_utc = stamp.tz_localize('utc')

In [69]: stamp_utc.tz_convert('Asia/Shanghai')
Out[69]: Timestamp('2015-08-12 12:00:00+0800', tz='Asia/Shanghai')

In [70]: # 在创建 Timestamp 时，还可以传入一个时区信息：

In [71]: stamp_moscow=pd.Timestamp('2015-08-12 04:00',tz='Europe/Moscow')

In [72]: stamp_moscow
Out[72]: Timestamp('2015-08-12 04:00:00+0400', tz='Europe/Moscow') 
```

　　时区意识型 Timestamp 对象在内部保存了一个 UTC 时间戳值（自 UNIX 纪元（1970 年 1 月 1 日）算起的纳秒数）。这个 UTC 值在时区转换过程中是不会发生变化的：

```py
In [79]: stamp_utc.value
Out[79]: 1439352000000000000

In [80]: stamp_utc.tz_convert('US/Eastern').value
Out[80]: 1439352000000000000 
```

## 四、不同时区之间的运算

　　如果两个时间序列的时区不同，在将它们合并到一起时，最终结果就会是 UTC。由于时间戳其实是以 UTC 存储的，所以这是一个很简单的运算，并不需要发生任何转换：

```py
In [92]: rng = pd.date_range('3/7/2015 9:30', periods=10,freq='B')

In [93]: ts = Series(np.random.randn(len(rng)),index=rng)

In [94]: ts
Out[94]: 
2015-03-09 09:30:00    0.240064
2015-03-10 09:30:00   -1.954718
2015-03-11 09:30:00   -0.741628
2015-03-12 09:30:00   -0.866897
2015-03-13 09:30:00   -0.139750
2015-03-16 09:30:00   -1.678531
2015-03-17 09:30:00    0.711531
2015-03-18 09:30:00    0.676227
2015-03-19 09:30:00    1.325030
2015-03-20 09:30:00    0.161045
Freq: B, dtype: float64

In [95]: ts1 = ts[:7].tz_localize('Europe/London')

In [96]: ts2 = ts1[2:].tz_convert('Europe/Moscow')

In [97]: result = ts1 + ts2

In [98]: result.index
Out[98]: 
DatetimeIndex(['2015-03-09 09:30:00+00:00', '2015-03-10 09:30:00+00:00',
               '2015-03-11 09:30:00+00:00', '2015-03-12 09:30:00+00:00',
               '2015-03-13 09:30:00+00:00', '2015-03-16 09:30:00+00:00',
               '2015-03-17 09:30:00+00:00'],
              dtype='datetime64[ns]', freq='B', tz='UTC') 
```

## 五、作业

　　好了，同学们今天的作业是同学们自学一下夏令时（因为中国没有夏令时，所以 mumu 在这里就不讲了，不过夏令时依然很重要，Python 会自动检测夏令时的，所以这里不必担心）。同时希望同学们能记忆一下一些常用的时区的名称。