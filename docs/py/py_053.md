# 第 3 节 Python 进阶（上）

作者：Vamei 出处：http://www.cnblogs.com/vamei 欢迎转载，也请保留这段声明。谢谢！

Python 基础介绍了基本概念，特别是对象和类。

进阶教程对基础教程的进一步拓展，说明 Python 的细节。希望在进阶教程之后，你对 Python 有一个更全面的认识。

## 一、词典

之前我们说了，列表是 Python 里的一个类。一个特定的表，比如说 nl = [1,3,8]，就是这个类的一个对象。我们可以调用这个对象的一些方法，比如 nl.append(15)。 我们要介绍一个新的类，**词典 (dictionary)**。与列表相似，词典也可以**储存多个元素**。这种储存多个元素的对象称为**容器(container)**。

### 1、基本概念

常见的创建词典的方法:

```py
>>>dic = {'tom':11, 'sam':57,'lily':100}

>>>print type(dic) 
```

词典和表类似的地方，是包含有**多个元素**，每个元素以逗号分隔。但词典的元素包含有两部分，**键**和**值**，常见的是以字符串来表示键，也可以使用数字或者真值来表示键（不可变的对象可以作为键）。值可以是任意对象。键和值两者一一对应。

比如上面的例子中，‘tom’对应 11，'sam 对应 57，'lily'对应 100

与表不同的是，词典的元素**没有顺序**。你**不能通过下标引用元素**。词典是**通过键来引用**。

```py
>>>print dic['tom']

>>>dic['tom'] = 30

>>>print dic 
```

构建一个新的空的词典：

```py
>>>dic = {}

>>>print dic 
```

在词典中增添一个新元素的方法：

```py
>>>dic['lilei'] = 99

>>>print dic 
```

这里，我们引用一个新的键，并赋予它对应的值。

### 2、词典元素的循环调用

```py
dic = {'lilei': 90, 'lily': 100, 'sam': 57, 'tom': 90}
for key in dic:
    print dic[key] 
```

**在循环中，dict 的每个键，被提取出来，赋予给 key 变量。**

通过 print 的结果，我们可以再次确认，dic 中的元素是没有顺序的。

### 3、词典的常用方法

```py
>>>print dic.keys()           # 返回 dic 所有的键

>>>print dic.values()         # 返回 dic 所有的值

>>>print dic.items()          # 返回 dic 所有的元素（键值对）

>>>dic.clear()                # 清空 dic，dict 变为{} 
```

另外有一个很常用的用法：

```py
>>>del dic['tom']             # 删除 dic 的‘tom’元素 
```

**del**是 Python 中保留的关键字，用于删除对象。

与表类似，你可以用**len()**查询词典中的元素总数。

```py
>>>print len(dic) 
```

## 二、文本文件的输入输出

Python 具有基本的文本文件读写功能。Python 的标准库提供有更丰富的读写功能。

文本文件的读写主要通过**open()**所构建的文件对象来实现。

### 1、创建文件对象

我们打开一个文件，并使用一个对象来表示该文件：

```py
对象名 = open(文件名，模式) 
```

最常用的模式有：

*   **r** 打开只读文件，该文件必须存在。
*   **r+** 打开可读写的文件，该文件必须存在。
*   **w** 打开只写文件，若文件存在则文件长度清为 0，即该文件内容会消失。若文件不存在则建立该文件。
*   **w+** 打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。
*   **a** 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。
*   **a+** 以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。
*   上述的形态字符串都可以再加一个 b 字符，如 rb、w+b 或 ab＋等组合，加入 b 字符用来告诉函数库打开的文件为二进制文件，而非纯文字文件。

比如：

```py
>>>f = open("test.txt","r") 
```

### 2、文件对象的方法

读取：

```py
content = f.read(N)          # 读取 N bytes 的数据

content = f.readline()       # 读取一行

content = f.readlines()      # 读取所有行，储存在列表中，每个元素是一行。 
```

写入：

```py
f.write('I like apple!\n')      # 将'I like apple'写入文件并换行 
```

关闭文件：

```py
f.close()   # 不要忘记关闭文件 
```

## 三、模块

我们之前看到了函数和对象。从本质上来说，它们都是为了更好的组织已经有的程序，以方便重复利用。

**模块(module)**也是为了同样的目的。在 Python 中，**一个.py 文件就构成一个模块**。通过模块，你可以**调用其它文件中的程序**。

### 1、引入模块

我们先写一个 first.py 文件，内容如下：

```py
def laugh():
    print 'HaHaHaHa' 
```

再写一个 second.py，并引入 first 中的程序：

```py
import first   #将 first 文件引入

for i in range(10):
    first.laugh() 
```

在 second.py 中，我们使用了 first.py 中定义的 laugh()函数。

引入模块后，可以通过 **模块.对象** 的方式来调用引入模块中的某个对象。上面例子中，first 为引入的模块，laugh()是我们所引入的对象。

Python 中还有其它的引入方式：

```py
import a as b             # 引入模块 a，并将模块 a 重命名为 b

from a import function1   # 从模块 a 中引入 function1 对象。调用 a 中对象时，我们不用再说明模块，即直接使用 function1，而不是 a.function1。

from a import *           # 从模块 a 中引入所有对象。调用 a 中对象时，我们不用再说明模块，即直接使用对象，而不是 a.对象。 
```

这些引用方式，可以方便后面的程序书写。

### 2、搜索路径

Python 会在以下路径中搜索它想要寻找的模块：

*   程序所在的文件夹

*   操作系统环境变量 PYTHONPATH 所包含的路径

*   标准库的安装路径

如果你有自定义的模块，或者下载的模块，可以根据情况放在相应的路径，以便 Python 可以找到。

### 3、模块包

可以将功能相似的模块放在同一个文件夹（比如说 this_dir）中，构成一个模块包。通过

```py
import this_dir.module 
```

引入 this_dir 文件夹中的 module 模块。

该文件夹中必须包含一个 **__init__.py** 的文件，提醒 Python，该文件夹为一个模块包。__init__.py **可以是一个空文件**。

## 四、函数的参数传递

我们已经接触过函数(function)的**参数(arguments)传递**。当时我们根据**位置**，传递对应的参数。我们将接触更多的参数传递方式。

回忆一下位置传递：

```py
def f(a,b,c):
    return a+b+c

print(f(1,2,3)) 
```

在调用 f 时，1，2，3 根据位置分别传递给了 a,b,c。

### 1、关键字传递

有些情况下，用位置传递会感觉比较死板。**关键字(keyword)传递是根据每个参数的名字传递参数**。关键字并不用遵守位置的对应关系。依然沿用上面 f 的定义，更改调用方式：

```py
print(f(c=3,b=2,a=1)) 
```

关键字传递可以和位置传递混用。但位置参数要出现在关键字参数之前：

```py
print(f(1,c=3,b=2)) 
```

### 2、参数默认值

在**定义函数**的时候，使用形如 a=19 的方式，可以给参数赋予默认值(default)。如果该参数最终没有被传递值，将使用该默认值。

```py
def f(a,b,c=10):
    return a+b+c

print(f(3,2))
print(f(3,2,1)) 
```

在第一次调用函数 f 时， 我们并没有足够的值，c 没有被赋值，c 将使用默认值 10.

第二次调用函数的时候，c 被赋值为 1，不再使用默认值。

### 3、包裹传递

在**定义函数**时，我们有时候并不知道调用的时候会传递多少个参数。这时候，包裹(packing)位置参数，或者包裹关键字参数，来进行参数传递，会非常有用。

下面是**包裹位置传递**的例子：

```py
def func(*name):
    print type(name)
    print name

func(1,4,6)
func(5,6,7,1,2,3) 
```

两次调用，尽管参数个数不同，都基于同一个 func 定义。**在 func 的参数表中，所有的参数被 name 收集，根据位置合并成一个元组(tuple)**，这就是包裹位置传递。

为了提醒 Python 参数，name 是包裹位置传递所用的元组名，在定义 func 时，**在 name 前加*号**。

下面是**包裹关键字传递**的例子：

```py
def func(**dict):
    print type(dict)
    print dict

func(a=1,b=9)
func(m=2,n=1,c=11) 
```

与上面一个例子类似，dict 是一个字典，收集所有的关键字，传递给函数 func。为了提醒 Python，参数 dict 是包裹关键字传递所用的字典，**在 dict 前加** * *。

包裹传递的关键在于**定义函数时**，在相应元组或字典前加 * 或 * * 。

### 4、解包裹

* 和 **，也可以在**调用的时候**使用，即**解包裹(unpacking)**, 下面为例：

```py
def func(a,b,c):
    print a,b,c

args = (1,3,4)
func(*args) 
```

在这个例子中，所谓的解包裹，**就是在传递 tuple 时，让 tuple 的每一个元素对应一个位置参数**。在调用 func 时使用 * ，是为了提醒 Python：我想要把 args 拆成分散的三个元素，分别传递给 a,b,c。（设想一下在调用 func 时，args 前面没有 * 会是什么后果？）

相应的，也存在对词典的解包裹，使用相同的 func 定义，然后：

```py
dict = {'a':1,'b':2,'c':3}
func(**dict) 
```

> 在传递词典 dict 时，让词典的每个键值对作为一个关键字传递给 func。

### 5、混合

在定义或者调用参数时，参数的几种传递方式可以混合。但在过程中要小心前后顺序。基本原则是：**先位置，再关键字，再包裹位置，再包裹关键字**，并且根据上面所说的原理细细分辨。

> 注意：请注意定义时和调用时的区分。包裹和解包裹并不是相反操作，是两个相对独立的过程。

## 作业

#### 1、按照过程，在实验楼环境下运行本节所有代码，并截图。

#### 2、建立一个 record.txt 的文档，写入内容如下:

```py
tom, 12, 86
Lee, 15, 99
Lucy, 11, 58
Joseph, 19, 56 
```

再从 record.txt 中读取文件并打印。