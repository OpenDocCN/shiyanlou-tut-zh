# 第 9 节 重采样及频率转换

## 一、实验介绍

　　重采样（resampling）指的是将时间序列从一个频率转换到另一个频率的处理过程。将高频率数据聚合到低频率称为降采样（downsampling），而将低频率数据转换到高频率称为升采样（upsampling）。并不是所有的重采样都能被划分到这两个大类中。例如，将 W-WED（每周三）转换为 W-FRI 即不是降采样也不是升采样。

　　pandas 对象都带有一个 resample 方法，它是各种频率转换工作的主力函数：

```py
In [177]: rng = pd.date_range('1/1/2000',periods=100,freq='D')

In [178]: ts = Series(randn(len(rng)), index = rng)

In [179]: ts.resample('M', how='mean')
Out[179]: 
2000-01-31    0.071116
2000-02-29    0.092083
2000-03-31    0.121808
2000-04-30    0.878650
Freq: M, dtype: float64

In [180]: ts.resample('M',how='mean',kind='period')
Out[180]: 
2000-01    0.071116
2000-02    0.092083
2000-03    0.121808
2000-04    0.878650
Freq: M, dtype: float64 
```

　　resample 是一个灵活高效的方法，可用于处理非常大得时间序列。我们通过一系列的示例说明其用法。

resample 方法的参数：

```py
| 参数 | 说明 |
|------|------|
| freq | 表示重采样频率的字符串或 DataOffset，例如'M'、'5min'或 Second（15） |
| how = 'mean' | 用于产生聚合值的函数名或数组函数，例如'mean'、'ohlc'、np.max 等。默认为'mean'。其他常用的值有：'first'、'last'、'median'、'ohlc'、'max'、'min' |
| axis = 0 | 重采样的轴，默认为 axis = 0 |
| closed = 'right' | 在降采样中，各时间段的哪一端是闭合（即包含）的，'right'或'left'。默认为'right' |
| label = 'right' | 在降采样中，如何设置聚合值的标签，'right'或'left'（面元的右边界或左边界）。例如，9：30 到 9：35 之间的这 5 分钟会被标记为 9：30 或 9：35。默认为'right' |
| loffset = None | 面元标签的时间校正值 |
| limit = None | 在前向或后向填充时，允许填充的最大时期数 |
| kind = None | 聚合到时期（'period'）或时间戳（'timestamp'），默认聚合到时间序列的索引类型 |
| convention = None | 当重采样时期时，降低频率转换到高频率所采用的约定（'start'或'end'）。默认为'end' |
```

## 二、降采样

　　将数据聚合到规整的低频率是一件非常普通的时间序列处理任务。待聚合的数据不必拥有固定的频率，期望的频率会自动定义聚合的面元边界，这些面元用于将时间序列拆分为多个片段。例如，要转换到月度频率（‘M’或‘BM’），数据需要被划分到多个单月时间段。各时间段都是半开放的。一个数据点只能属于一个时间段，所有时间段的并集必须能组成整个时间帧。在用 resample 对数据进行降采样时，需要考虑两样东西：

*   各区间哪边是闭合的。

*   如何标记各个聚合面元，用区间的开头还是末尾。

    　　首先，我们来看一些“1 分钟”数据：

```py
In [185]: rng = pd.date_range('1/1/2000',periods=12,freq='T')

In [186]: ts=Series(np.arange(12),index=rng)

In [187]: ts
Out[187]: 
2000-01-01 00:00:00     0
2000-01-01 00:01:00     1
2000-01-01 00:02:00     2
2000-01-01 00:03:00     3
2000-01-01 00:04:00     4
2000-01-01 00:05:00     5
2000-01-01 00:06:00     6
2000-01-01 00:07:00     7
2000-01-01 00:08:00     8
2000-01-01 00:09:00     9
2000-01-01 00:10:00    10
2000-01-01 00:11:00    11
Freq: T, dtype: int64 
```

　　假设我们想要通过求和的方式将这些数据聚合到“5 分钟”块中：

```py
In [188]: ts.resample('5min',how='sum')
Out[188]: 
2000-01-01 00:00:00    10
2000-01-01 00:05:00    35
2000-01-01 00:10:00    21
Freq: 5T, dtype: int64 
```

　　最后，我们可能希望对结果索引做一些位移，比如从右边界减去一秒以便更容易明白该时间戳到底表示的是哪个区间。只需通过 loffset 设置一个字符串或日期偏移量即可实现这个目的：

```py
In [190]: ts.resample('5min',how='sum',loffset='-1s')
Out[190]: 
1999-12-31 23:59:59    10
2000-01-01 00:04:59    35
2000-01-01 00:09:59    21
Freq: 5T, dtype: int64 
```

## 三、升采样和插值

　　在将数据从低频率转换到高频率时，就不需要聚合了。我们来看一个带有一些周型数据的 DataFrame：

```py
In [197]: frame = DataFrame(np.random.randn(2,4),
   .....: index = pd.date_range('1/1/2000',periods=2,
   .....: freq='W-WED'),
   .....: columns=['Colorado','Texas','New York','Ohio'])

In [198]: frame
Out[198]: 
            Colorado     Texas  New York      Ohio
2000-01-05  1.179206 -0.051018 -0.121771  1.891284
2000-01-12  0.050851  0.895658  1.204723 -0.007893

In [199]: # 将其重采样到日频率，默认会引入缺失值

In [200]: df_daily=frame.resample('D')

In [201]: df_daily
Out[201]: 
            Colorado     Texas  New York      Ohio
2000-01-05  1.179206 -0.051018 -0.121771  1.891284
2000-01-06       NaN       NaN       NaN       NaN
2000-01-07       NaN       NaN       NaN       NaN
2000-01-08       NaN       NaN       NaN       NaN
2000-01-09       NaN       NaN       NaN       NaN
2000-01-10       NaN       NaN       NaN       NaN
2000-01-11       NaN       NaN       NaN       NaN
2000-01-12  0.050851  0.895658  1.204723 -0.007893

In [202]: #resampling 的填充和插值方式跟 fillna 和 reindex 的一样

In [203]: frame.resample('D',fill_method='ffill')
Out[203]: 
            Colorado     Texas  New York      Ohio
2000-01-05  1.179206 -0.051018 -0.121771  1.891284
2000-01-06  1.179206 -0.051018 -0.121771  1.891284
2000-01-07  1.179206 -0.051018 -0.121771  1.891284
2000-01-08  1.179206 -0.051018 -0.121771  1.891284
2000-01-09  1.179206 -0.051018 -0.121771  1.891284
2000-01-10  1.179206 -0.051018 -0.121771  1.891284
2000-01-11  1.179206 -0.051018 -0.121771  1.891284
2000-01-12  0.050851  0.895658  1.204723 -0.007893

In [204]: # 这里也可以只填充指定的时期数

In [205]: frame.resample('D',fill_method='ffill',limit=2)
Out[205]: 
            Colorado     Texas  New York      Ohio
2000-01-05  1.179206 -0.051018 -0.121771  1.891284
2000-01-06  1.179206 -0.051018 -0.121771  1.891284
2000-01-07  1.179206 -0.051018 -0.121771  1.891284
2000-01-08       NaN       NaN       NaN       NaN
2000-01-09       NaN       NaN       NaN       NaN
2000-01-10       NaN       NaN       NaN       NaN
2000-01-11       NaN       NaN       NaN       NaN
2000-01-12  0.050851  0.895658  1.204723 -0.007893

In [206]: # 注意，新的日期索引完全没必要跟旧的相交

In [207]: frame.resample('W-THU',fill_method='ffill')
Out[207]: 
            Colorado     Texas  New York      Ohio
2000-01-06  1.179206 -0.051018 -0.121771  1.891284
2000-01-13  0.050851  0.895658  1.204723 -0.007893 
```

## 四、通过时期进行重采样

　　对那些使用时期索引的数据进行重采样是件非常简单的事情：

```py
In [209]: frame = DataFrame(np.random.randn(24,4),
   .....: index = pd.period_range('1-2000','12-2001',
   .....: freq = 'M'),
   .....: columns = ['Colorado','Texas','New York','Ohio'])

In [210]: frame[:5]
Out[210]: 
         Colorado     Texas  New York      Ohio
2000-01  1.870831  0.931047  1.377149 -1.448728
2000-02  0.495151 -0.612399 -0.728929 -2.043195
2000-03  0.701207 -1.404510  0.041026  0.188793
2000-04  0.368950  0.104393 -0.363553  1.608494
2000-05 -1.401590 -1.769710  1.553946  1.230825

In [211]: annual_frame = frame.resample('A-DEC',how='mean')

In [212]: annual_frame
Out[212]: 
      Colorado     Texas  New York      Ohio
2000  0.029914 -0.090170 -0.199085  0.023159
2001 -0.338836  0.523542  0.071127 -0.006438 
```

　　升采样要稍微麻烦一些，因为我们必须决定新频率中各区间的哪端用于放置原来的值，就像 asfreq 方法那样。convention 参数默认为‘start’，可设置为‘end’：

```py
In [216]: annual_frame.resample('Q-DEC',fill_method='ffill')
Out[216]: 
        Colorado     Texas  New York      Ohio
2000Q1  0.029914 -0.090170 -0.199085  0.023159
2000Q2  0.029914 -0.090170 -0.199085  0.023159
2000Q3  0.029914 -0.090170 -0.199085  0.023159
2000Q4  0.029914 -0.090170 -0.199085  0.023159
2001Q1 -0.338836  0.523542  0.071127 -0.006438
2001Q2 -0.338836  0.523542  0.071127 -0.006438
2001Q3 -0.338836  0.523542  0.071127 -0.006438
2001Q4 -0.338836  0.523542  0.071127 -0.006438

In [217]: annual_frame.resample('Q-DEC',fill_method='ffill',
convention = 'end')
Out[217]: 
        Colorado     Texas  New York      Ohio
2000Q4  0.029914 -0.090170 -0.199085  0.023159
2001Q1  0.029914 -0.090170 -0.199085  0.023159
2001Q2  0.029914 -0.090170 -0.199085  0.023159
2001Q3  0.029914 -0.090170 -0.199085  0.023159
2001Q4 -0.338836  0.523542  0.071127 -0.006438 
```

　　由于时间指的是时间区间，所以升采样和降采样的规则就比较严格：

*   在降采样中，目标频率必须是原频率的子时期（subperiod）

*   在升采样中，目标频率必须是原频率的超时期（superperiod）

    　　如果不满足这些条件，就会引发异常。这主要影响的是按季、年、周计算的频率。例如，由 Q-MAR 定义的时间区间只能升采样为 A-MAR、A-JUN、A-SEP、A-DEC 等：

```py
In [219]: annual_frame.resample('Q-MAR',fill_method='ffill')
Out[219]: 
        Colorado     Texas  New York      Ohio
2000Q4  0.029914 -0.090170 -0.199085  0.023159
2001Q1  0.029914 -0.090170 -0.199085  0.023159
2001Q2  0.029914 -0.090170 -0.199085  0.023159
2001Q3  0.029914 -0.090170 -0.199085  0.023159
2001Q4 -0.338836  0.523542  0.071127 -0.006438
2002Q1 -0.338836  0.523542  0.071127 -0.006438
2002Q2 -0.338836  0.523542  0.071127 -0.006438
2002Q3 -0.338836  0.523542  0.071127 -0.006438 
```

## 五、作业

　　好了，同学们今天的内容在下来以后，同学们好好消化一下。熟悉重采样的知识是我们对时间序列处理的基础，同学们将上面的代码自己在环境中实现一下吧。