# 第 1 节 Pandas 结构化数据（上）

## 一、实验说明

Pandas 是 python 的一个数据分析包，属于 PyData 项目的一部分。Pandas 最初被作为金融数据分析工具而开发出来，因此 pandas 为时间序列分析提供了很好的支持。 Pandas 的名称来自于面板数据（panel data）和 python 数据分析（data analysis）。panel data 是经济学中关于多维数据集的一个术语，在 Pandas 中也提供了 panel 的数据类型。

### 1\. 环境登录

无需密码自动登录，系统用户名 shiyanlou

### 2\. 环境介绍

本课程实验环境使用 Spyder。首先打开 terminal，然后输入以下命令：

```py
spyder -w scientific-python-lectures   (-w 参数指定工作目录) 
```

关于 Spyder 的使用可参考文档：https://pythonhosted.org/spyder/

本实验基本在控制台下进行，可关闭 spyder 中的其余窗口，只保留控制台。如需要调出窗口，可以通过 view->windows and toolbar 调出。比如希望在 py 文件中编写代码，可以 view->windows and toolbar->Editor 调出编辑器窗口。

![此处输入图片的描述](img/document-uid8834labid1233timestamp1468334229103.jpg)

## 二、实验内容

载入需要的包：

```py
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt 
```

## Series

Series 是一个一维类数组对象，包含一列数据与与其关联的一列数据标签，数据标签即为数据的序列。

### 创建一个 Series：

```py
s = pd.Series([1,3,5,np.nan,6,8])
s 
```

输出：

```py
0     1
1     3
2     5
3   NaN
4     6
5     8
dtype: float64 
```

## DataFrame

DataFrame 是一个表格化的数据结构，它同时拥有行序号与列序号。

### 创建一个 DataFrame

通过传递一个 numpy 数组创建 DataFrame

```py
#创建日期索引序列 
dates = pd.date_range('20130101', periods=6)
#创建 Dataframe，其中 index 决定索引序列，columns 决定列名
df = pd.DataFrame(np.random.randn(6,4), index=dates, columns=list('ABCD'))
df 
```

输出：

```py
 A         B         C         D
2013-01-01  0.469112 -0.282863 -1.509059 -1.135632
2013-01-02  1.212112 -0.173215  0.119209 -1.044236
2013-01-03 -0.861849 -2.104569 -0.494929  1.071804
2013-01-04  0.721555 -0.706771 -1.039575  0.271860
2013-01-05 -0.424972  0.567020  0.276232 -1.087401
2013-01-06 -0.673690  0.113648 -1.478427  0.524988 
```

通过传递一个字典创建 DataFrame

```py
df2 = pd.DataFrame({ 'A' : 1.,
                     'B' : pd.Timestamp('20130102'),
                     'C' : pd.Series(1,index=list(range(4)),dtype='float32'),
                     'D' : np.array([3] * 4,dtype='int32'),
                     'E' : pd.Categorical(["test","train","test","train"]),
                     'F' : 'foo' }) 
```

输出：

```py
 A          B  C  D      E    F
0  1 2013-01-02  1  3   test  foo
1  1 2013-01-02  1  3  train  foo
2  1 2013-01-02  1  3   test  foo
3  1 2013-01-02  1  3  train  foo 
```

查询每一列的数据结构

```py
df2.dtypes 
```

输出：

```py
A           float64
B    datetime64[ns]
C           float32
D             int32
E          category
F            object
dtype: object 
```

## 数据观察

观察开头的数据

```py
df.head() 
```

输出：

```py
 A         B         C         D
2013-01-01  0.469112 -0.282863 -1.509059 -1.135632
2013-01-02  1.212112 -0.173215  0.119209 -1.044236
2013-01-03 -0.861849 -2.104569 -0.494929  1.071804
2013-01-04  0.721555 -0.706771 -1.039575  0.271860
2013-01-05 -0.424972  0.567020  0.276232 -1.087401 
```

观察末尾的数据

```py
df.tail(3)

                   A         B         C         D
2013-01-04  0.721555 -0.706771 -1.039575  0.271860
2013-01-05 -0.424972  0.567020  0.276232 -1.087401
2013-01-06 -0.673690  0.113648 -1.478427  0.524988 
```

显示索引

```py
df.index 
```

输出：

```py
DatetimeIndex(['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04',
               '2013-01-05', '2013-01-06'],
              dtype='datetime64[ns]', freq='D', tz=None) 
```

显示列

```py
df.columns 
```

输出：

```py
Index([u'A', u'B', u'C', u'D'], dtype='object') 
```

显示底层 numpy 结构

```py
df.values 
```

输出：

```py
array([[ 0.4691, -0.2829, -1.5091, -1.1356],
       [ 1.2121, -0.1732,  0.1192, -1.0442],
       [-0.8618, -2.1046, -0.4949,  1.0718],
       [ 0.7216, -0.7068, -1.0396,  0.2719],
       [-0.425 ,  0.567 ,  0.2762, -1.0874],
       [-0.6737,  0.1136, -1.4784,  0.525 ]]) 
```

DataFrame 的基本统计学属性预览

```py
df.describe() 
```

输出：

```py
 A         B         C         D
count  6.000000  6.000000  6.000000  6.000000       #数量
mean   0.073711 -0.431125 -0.687758 -0.233103       #平均值
std    0.843157  0.922818  0.779887  0.973118       #标准差
min   -0.861849 -2.104569 -1.509059 -1.135632       #最小值
25%   -0.611510 -0.600794 -1.368714 -1.076610       #正态分布 25%
50%    0.022070 -0.228039 -0.767252 -0.386188       #正态分布 50%
75%    0.658444  0.041933 -0.034326  0.461706       #正态分布 75%
max    1.212112  0.567020  0.276232  1.071804       #最大值 
```

转置

```py
df.T 
```

输出：

```py
 2013-01-01  2013-01-02  2013-01-03  2013-01-04  2013-01-05  2013-01-06
A    0.469112    1.212112   -0.861849    0.721555   -0.424972   -0.673690
B   -0.282863   -0.173215   -2.104569   -0.706771    0.567020    0.113648
C   -1.509059    0.119209   -0.494929   -1.039575    0.276232   -1.478427
D   -1.135632   -1.044236    1.071804    0.271860   -1.087401    0.524988 
```

根据某一轴的索引进行排序

```py
df.sort_index(axis=1, ascending=False) 
```

输出：

```py
 D         C         B         A
2013-01-01 -1.135632 -1.509059 -0.282863  0.469112
2013-01-02 -1.044236  0.119209 -0.173215  1.212112
2013-01-03  1.071804 -0.494929 -2.104569 -0.861849
2013-01-04  0.271860 -1.039575 -0.706771  0.721555
2013-01-05 -1.087401  0.276232  0.567020 -0.424972
2013-01-06  0.524988 -1.478427  0.113648 -0.673690 
```

根据某一列的数值进行排序

```py
df.sort(columns='B') 
```

输出：

```py
 A         B         C         D
2013-01-03 -0.861849 -2.104569 -0.494929  1.071804
2013-01-04  0.721555 -0.706771 -1.039575  0.271860
2013-01-01  0.469112 -0.282863 -1.509059 -1.135632
2013-01-02  1.212112 -0.173215  0.119209 -1.044236
2013-01-06 -0.673690  0.113648 -1.478427  0.524988
2013-01-05 -0.424972  0.567020  0.276232 -1.087401 
```

## 选择/切片

选择单独的一列，返回 Serires，与 df.A 效果相当。

```py
df['A'] 
```

输出：

```py
2013-01-01    0.469112
2013-01-02    1.212112
2013-01-03   -0.861849
2013-01-04    0.721555
2013-01-05   -0.424972
2013-01-06   -0.673690
Freq: D, Name: A, dtype: float64 
```

位置切片

```py
df[0:3] 
```

输出：

```py
 A         B         C         D
2013-01-01  0.469112 -0.282863 -1.509059 -1.135632
2013-01-02  1.212112 -0.173215  0.119209 -1.044236
2013-01-03 -0.861849 -2.104569 -0.494929  1.071804 
```

索引切片

```py
df['20130102':'20130104'] 
```

输出：

```py
 A         B         C         D
2013-01-02  1.212112 -0.173215  0.119209 -1.044236
2013-01-03 -0.861849 -2.104569 -0.494929  1.071804
2013-01-04  0.721555 -0.706771 -1.039575  0.271860 
```

### 通过标签选择

```py
df.loc[dates[0]] 
```

输出：

```py
A    0.469112
B   -0.282863
C   -1.509059
D   -1.135632
Name: 2013-01-01 00:00:00, dtype: float64 
```

对多个轴同时通过标签进行选择

```py
df.loc[:,['A','B']] 
```

输出：

```py
 A         B
2013-01-01  0.469112 -0.282863
2013-01-02  1.212112 -0.173215
2013-01-03 -0.861849 -2.104569
2013-01-04  0.721555 -0.706771
2013-01-05 -0.424972  0.567020
2013-01-06 -0.673690  0.113648 
```

获得某一个单元的数据

```py
df.loc[dates[0],'A']
0.46911229990718628 
```

速度更快的做法

```py
df.at[dates[0],'A']
0.46911229990718628 
```

### 通过位置进行选择

```py
df.iloc[3] 
```

输出：

```py
A    0.721555
B   -0.706771
C   -1.039575
D    0.271860
Name: 2013-01-04 00:00:00, dtype: float64 
```

切片

```py
df.iloc[3:5,0:2] 
```

输出：

```py
 A         B
2013-01-04  0.721555 -0.706771
2013-01-05 -0.424972  0.567020 
```

列表选择

```py
df.iloc[[1,2,4],[0,2]] 
```

输出：

```py
 A         C
2013-01-02  1.212112  0.119209
2013-01-03 -0.861849 -0.494929
2013-01-05 -0.424972  0.276232 
```

获得某一个单元的数据

```py
df.iloc[1,1] 
```

输出：

```py
-0.17321464905330858 
```

更快的做法：

```py
df.iat[1,1] 
```

输出：

```py
-0.17321464905330858 
```

### 布尔索引

根据某一列的数据达成条件进行索引

```py
df[df.A > 0] 
```

输出：

```py
 A         B         C         D
2013-01-01  0.469112 -0.282863 -1.509059 -1.135632
2013-01-02  1.212112 -0.173215  0.119209 -1.044236
2013-01-04  0.721555 -0.706771 -1.039575  0.271860 
```

获得大于零的项的数值

```py
df[df > 0] 
```

输出：

```py
 A         B         C         D
2013-01-01  0.469112       NaN       NaN       NaN
2013-01-02  1.212112       NaN  0.119209       NaN
2013-01-03       NaN       NaN       NaN  1.071804
2013-01-04  0.721555       NaN       NaN  0.271860
2013-01-05       NaN  0.567020  0.276232       NaN
2013-01-06       NaN  0.113648       NaN  0.524988 
```

使用 `isin()` 方法进行过滤

```py
df2 = df.copy()
df2['E'] = ['one', 'one','two','three','four','three']
df2 
```

输出：

```py
 A         B         C         D      E
2013-01-01  0.469112 -0.282863 -1.509059 -1.135632    one
2013-01-02  1.212112 -0.173215  0.119209 -1.044236    one
2013-01-03 -0.861849 -2.104569 -0.494929  1.071804    two
2013-01-04  0.721555 -0.706771 -1.039575  0.271860  three
2013-01-05 -0.424972  0.567020  0.276232 -1.087401   four
2013-01-06 -0.673690  0.113648 -1.478427  0.524988  three

df2[df2['E'].isin(['two','four'])] 
```

输出：

```py
 A         B         C         D     E
2013-01-03 -0.861849 -2.104569 -0.494929  1.071804   two
2013-01-05 -0.424972  0.567020  0.276232 -1.087401  four 
```

## 赋值

新增一列，根据索引排列

```py
s1 = pd.Series([1,2,3,4,5,6], index=pd.date_range('20130102', periods=6))
s1 
```

输出：

```py
2013-01-02    1
2013-01-03    2
2013-01-04    3
2013-01-05    4
2013-01-06    5
2013-01-07    6
Freq: D, dtype: int64 
```

输入：

```py
df['F'] = s1
df.at[dates[0],'A'] = 0
df.iat[0,1] = 0
df.loc[:,'D'] = np.array([5] * len(df))
df 
```

输出：

```py
 A         B         C  D   F
2013-01-01  0.000000  0.000000 -1.509059  5 NaN
2013-01-02  1.212112 -0.173215  0.119209  5   1
2013-01-03 -0.861849 -2.104569 -0.494929  5   2
2013-01-04  0.721555 -0.706771 -1.039575  5   3
2013-01-05 -0.424972  0.567020  0.276232  5   4
2013-01-06 -0.673690  0.113648 -1.478427  5   5 
```

根据条件进行赋值

```py
df2 = df.copy()
df2[df2 > 0] = -df2
df2 
```

输出：

```py
 A         B         C  D   F
2013-01-01  0.000000  0.000000 -1.509059 -5 NaN
2013-01-02 -1.212112 -0.173215 -0.119209 -5  -1
2013-01-03 -0.861849 -2.104569 -0.494929 -5  -2
2013-01-04 -0.721555 -0.706771 -1.039575 -5  -3
2013-01-05 -0.424972 -0.567020 -0.276232 -5  -4
2013-01-06 -0.673690 -0.113648 -1.478427 -5  -5 
```

## 缺省项

在 pandas 中使用 `np.nan` 作为缺省项的值。

```py
df1 = df.reindex(index=dates[0:4], columns=list(df.columns) + ['E'])
df1.loc[dates[0]:dates[1],'E'] = 1
df1 
```

输出：

```py
 A         B         C  D   F   E
2013-01-01  0.000000  0.000000 -1.509059  5 NaN   1
2013-01-02  1.212112 -0.173215  0.119209  5   1   1
2013-01-03 -0.861849 -2.104569 -0.494929  5   2 NaN
2013-01-04  0.721555 -0.706771 -1.039575  5   3 NaN 
```

删除所有带有缺省项的行

```py
df1.dropna(how='any') 
```

输出：

```py
 A         B         C  D  F  E
2013-01-02  1.212112 -0.173215  0.119209  5  1  1 
```

填充缺省项

```py
df1.fillna(value=5) 
```

输出：

```py
 A         B         C  D  F  E
2013-01-01  0.000000  0.000000 -1.509059  5  5  1
2013-01-02  1.212112 -0.173215  0.119209  5  1  1
2013-01-03 -0.861849 -2.104569 -0.494929  5  2  5
2013-01-04  0.721555 -0.706771 -1.039575  5  3  5 
```

获得缺省项的布尔掩码：

```py
pd.isnull(df1) 
```

输出：

```py
 A      B      C      D      F      E
2013-01-01  False  False  False  False   True  False
2013-01-02  False  False  False  False  False  False
2013-01-03  False  False  False  False  False   True
2013-01-04  False  False  False  False  False   True 
```